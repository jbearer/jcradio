<!DOCTYPE html>
<!--
 *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
-->
<html lang='en'>
<head>

    <meta charset="utf-8">
    <!-- <meta name="description" content="WebRTC code samples"> -->
    <!-- <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- <meta itemprop="description" content="Client-side WebRTC code samples"> -->
    <!-- <meta itemprop="image" content="../../../images/webrtc-icon-192x192.png"> -->
    <!-- <meta itemprop="name" content="WebRTC code samples"> -->
    <!-- <meta name="mobile-web-app-capable" content="yes"> -->
    <!-- <meta id="theme-color" name="theme-color" content="#ffffff"> -->

    <base target="_blank">

    <title>Peer connection: audio only</title>
    
    <link rel="icon" href="data:;base64,=">
    <!-- <link rel="icon" sizes="192x192" href="../../../images/webrtc-icon-192x192.png"> -->
    <!-- <link href="//fonts.googleapis.com/css?family=Roboto:300,400,500,700" rel="stylesheet" type="text/css"> -->
    <!-- <link href="//fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css"> -->
    <!-- <link rel="stylesheet" href="../../../css/main.css"/> -->
    <!-- <link rel="stylesheet" href="css/main.css"/> -->
 
</head>

<body>

<div id="container">
    <label id='server'>Web Service URL <input required type="text" id="address" value="" title="hostname (or IP address) and port of the UV4L WebRTC Web Service"/></label>

    <h1><span>Test</span>
    </h1>

    <div id="audio">
        <div>
            <div class="label">Remote audio:</div>
            <audio id="audio1" autoplay controls></audio>
        </div>
    </div>

    <div id="buttons">
        <button id="callButton">Call</button>
        <button id="hangupButton">Hang Up</button>
    </div>


</div>

<hr>

<script>
    // Let's get a default address for the signalling server
    var address = document.getElementById('address').value;
    console.log("Address: ", address);
    if (!address || address === '') {
        var hostname = location.hostname;
        console.log("hostname: ", hostname);
        if (hostname) {
            address = hostname + ':' + (location.port || (location.protocol === 'https:' ? 443 : 80)) + '/webrtc';
            console.log("Address: ", address);
            document.getElementById('address').value = address;
        } else {
            console.log("Address: ", address);
            document.getElementById('address').value = "<host>:<port>/webrtc";
        }
    }
</script>

<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
<!-- <script src="webrtc_signalling.js"></script> -->

<script>
    /*
     *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
     *
     *  Use of this source code is governed by a BSD-style license
     *  that can be found in the LICENSE file in the root of the source
     *  tree.
     */
    /* global TimelineDataSeries, TimelineGraphView */

    'use strict';

    const audio1 = document.querySelector('audio#audio1');
    const callButton1 = document.querySelector('button#callButton');
    const hangupButton1 = document.querySelector('button#hangupButton');
    hangupButton1.disabled = true;
    callButton1.onclick = call;
    hangupButton1.onclick = hangup;

    var config = {"iceServers": [{"urls": ["stun:stun.l.google.com:19302"]}]};
    var options = {optional: []};

    var pc;
    var ws;


    var iceCandidates;
    var hasRemoteDesc;


    function call() {
        callButton1.disabled = true;
        console.log('Starting call');
        // Get the address to open WebSocket
        var address = document.getElementById('address').value;
        var protocol = location.protocol === "https:" ? "wss:" : "ws:";
        var wsurl = protocol + '//' + address;


        console.log("opening web socket: " + wsurl);
        ws = new WebSocket(wsurl);
        iceCandidates = [];
        hasRemoteDesc = false;


        function addIceCandidates() {
            if (hasRemoteDesc) {
                iceCandidates.forEach(function (candidate) {
                    pc.addIceCandidate(candidate,
                        function () {
                            console.log("IceCandidate added: " + JSON.stringify(candidate));
                        },
                        function (error) {
                            console.error("addIceCandidate error: " + error);
                        }
                    );
                });
                iceCandidates = [];
            }
        };

        ws.onopen = function () {
            // Reset everything on WebSocket open
            pc = new RTCPeerConnection(config, options);
            iceCandidates = [];
            hasRemoteDesc = false;

            pc.onicecandidate = function (event) {
                if (event.candidate) {
                    var candidate = {
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        sdpMid: event.candidate.sdpMid,
                        candidate: event.candidate.candidate
                    };
                    var request = {
                        what: "addIceCandidate",
                        data: JSON.stringify(candidate)
                    };
                    ws.send(JSON.stringify(request));
                } else {
                    console.log("end of candidates.");
                }
            };

            // Do some track
            console.log("Set PC ontrack");
            pc.ontrack = function (event) {
                console.log("HERE: ontrack");
                if (audio1.srcObject !== event.streams[0]) {
                    audio1.srcObject = event.streams[0];
                    hangupButton1.disabled = false;

                    console.log('Received remote stream');
                }
            };

            pc.onremovestream = function (event) {
                console.log("the stream has been removed: do your stuff now");
            };

            pc.ondatachannel = function (event) {
                console.log("a data channel is available: do your stuff with it");
                // For an example, see https://www.linux-projects.org/uv4l/tutorials/webrtc-data-channels/
            };


            /* kindly signal the remote peer that we would like to initiate a call */
            var request = {
                what: "call",
                options: {
                    // If forced, the hardware codec depends on the arch.
                    // (e.g. it's H264 on the Raspberry Pi)
                    // Make sure the browser supports the codec too.
                    force_hw_vcodec: true,
                    vformat: 30, /* 30=640x480, 30 fps */
                    trickle_ice: true
                }
            };
            console.log("send message " + JSON.stringify(request));
            ws.send(JSON.stringify(request));
        };


        ws.onmessage = function (evt) {
            var msg = JSON.parse(evt.data);
            var what = msg.what;
            var data = msg.data;

            console.log("received message " + JSON.stringify(msg));

            switch (what) {
                case "offer":
                    var mediaConstraints = {
                        optional: [],
                        mandatory: {
                            OfferToReceiveAudio: true,
                            OfferToReceiveVideo: false
                        }
                    };
                    pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(data)),
                            function onRemoteSdpSuccess() {
                                hasRemoteDesc = true;
                                addIceCandidates();
                                pc.createAnswer(function (sessionDescription) {
                                    pc.setLocalDescription(sessionDescription);
                                    var request = {
                                        what: "answer",
                                        data: JSON.stringify(sessionDescription)
                                    };
                                    ws.send(JSON.stringify(request));
                                }, function (error) {
                                    alert("failed to create answer: " + error);
                                }, mediaConstraints);
                            },
                            function onRemoteSdpError(event) {
                                alert('failed to set the remote description: ' + event);
                                ws.close();
                            }
                    );

                    break;

                case "answer":
                    break;

                case "message":
                    alert(msg.data);
                    break;

                case "iceCandidate": // received when trickle ice is used (see the "call" request)
                    if (!msg.data) {
                        console.log("Ice Gathering Complete");
                        break;
                    }
                    var elt = JSON.parse(msg.data);
                    let candidate = new RTCIceCandidate({sdpMLineIndex: elt.sdpMLineIndex, candidate: elt.candidate});
                    iceCandidates.push(candidate);
                    addIceCandidates(); // it internally checks if the remote description has been set
                    break;

                case "iceCandidates": // received when trickle ice is NOT used (see the "call" request)
                    var candidates = JSON.parse(msg.data);
                    for (var i = 0; candidates && i < candidates.length; i++) {
                        var elt = candidates[i];
                        let candidate = new RTCIceCandidate({sdpMLineIndex: elt.sdpMLineIndex, candidate: elt.candidate});
                        iceCandidates.push(candidate);
                    }
                    addIceCandidates();
                    break;
            }
        };

        ws.onclose = function (event) {
            console.log('socket closed with code: ' + event.code);
            if (pc) {
                pc.close();
                pc = null;
                ws = null;
            }
            audio1.srcObject = null;
        };

        ws.onerror = function (event) {
            alert("An error has occurred on the websocket (make sure the address is correct)!");
        };
    }



    function hangup() {
        console.log('Ending call');

        if (ws) {
            var request = {
                what: "hangup"
            };
            console.log("send message " + JSON.stringify(request));
            ws.send(JSON.stringify(request));
        }

        pc.close();
        pc = null;
        hangupButton1.disabled = true;
        callButton1.disabled = false;
    }

</script>



<!-- <script src="../../../js/third_party/graph.js"></script>

<script src="../../../js/lib/ga.js"></script> -->
</body>
</html>
